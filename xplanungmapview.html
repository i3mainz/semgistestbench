<html>
<head><title>XPlanung Mapview based on LinkedData</title>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
<script src="wicket.js" type="text/javascript"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"></script>
  <script src="leaflet.polylinedecorator.js"></script>
  <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
  <script src="rdfstore_min.js"></script>
  <script src="proj4.js"></script>
    <script src="xml2json.js"></script>
	    <script src="turf.min.js"></script>
  
<script>
var epsgdefs={"EPSG:25832":"+proj=utm +zone=32 +ellps=GRS80 +units=m +no_defs","EPSG:31467":"+proj=tmerc +lat_0=0 +lon_0=9 +k=1 +x_0=3500000 +y_0=0 +ellps=bessel +datum=potsdam +units=m +no_defs","EPSG:4326":"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs","EPSG:3587":"+proj=lcc +lat_1=45.7 +lat_2=44.18333333333333 +lat_0=43.31666666666667 +lon_0=-84.36666666666666 +x_0=6000000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"}
var prefixList="PREFIX owl: <http://www.w3.org/2002/07/owl#>  PREFIX geo: <http://www.opengis.net/ont/geosparql#> PREFIX wd: <http://www.wikidata.org/entity/> PREFIX foaf: <http://xmlns.com/foaf/0.1/>  PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>  PREFIX xml: <http://www.w3.org/XML/1998/namespace>  PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> PREFIX xerl: <http://www.xerleben.de/schema/2.0_1#> PREFIX xplan5: <http://www.xplanung.de/xplangml/5/0#> PREFIX semgis: <http://www.semgis.de/geodata#> "
var ttlprefixList="@prefix wd: <http://www.wikidata.org/entity/> . \n @prefix foaf: <http://xmlns.com/foaf/0.1/> . \n @prefix owl: <http://www.w3.org/2002/07/owl#> . \n @prefix geo: <http://www.opengis.net/ont/geosparql#> . \n @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> . \n @prefix xml: <http://www.w3.org/XML/1998/namespace> . \n @prefix xsd: <http://www.w3.org/2001/XMLSchema#> . \n @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> . \n @prefix kml: <http://www.opengis.net/kml/2.2#> . \n @prefix gml: <http://www.opengis.net/gml/3.2#> . \n @prefix xplan5: <http://www.xplanung.de/xplangml/5/0#> . \n "
var prefixMap={"http://www.w3.org/2002/07/owl#":"owl", "http://www.opengis.net/ont/geosparql#":"geo" 
, "http://www.wikidata.org/entity/":"wd", "http://xmlns.com/foaf/0.1/":"foaf", "http://www.w3.org/1999/02/22-rdf-syntax-ns#":"rdf", 
"http://www.w3.org/XML/1998/namespace":"xml", "http://www.w3.org/2001/XMLSchema#":"xsd", "http://www.w3.org/2000/01/rdf-schema#":"rdfs" ,
 "http://www.xerleben.de/schema/2.0_1#":"xerl", "http://www.xplanung.de/xplangml/5/0#":"xplan5", "http://www.opengis.net/gml/3.2":"gml", "http://www.opengis.net/kml/2.2#":"kml" }; 
var supportingOntologies={"AAA-Data":"https://cdn.rawgit.com/i3mainz/SemGISOntologies/0dc433aa7ff7db5cd122537a134e840a35f50027/AAA-Data/aaa6.ttl","AAA-Data Styles":"https://cdn.rawgit.com/i3mainz/SemGISOntologies/0dc433aa7ff7db5cd122537a134e840a35f50027/AAA-Data/aaa6_style.ttl","INSPIRE":"",
"Xerleben":"https://cdn.rawgit.com/i3mainz/SemGISOntologies/master/XErleben/xerleben2_1.ttl_mod.ttl","XPlanung":"https://cdn.rawgit.com/i3mainz/SemGISOntologies/0dc433aa7ff7db5cd122537a134e840a35f50027/XPlanung/xplanung5_0.ttl","XPlanung Styles":"https://cdn.rawgit.com/i3mainz/SemGISOntologies/0dc433aa7ff7db5cd122537a134e840a35f50027/XPlanung/xplanung5_0_style.ttl"}
var currdfstore=null;
var wkt = new Wkt.Wkt();
var firstcoords=[]
var decorators=[]
var lastimportAsTTL=""
var bboxpoint;
var bboxbuffer;
var constraints={}
var geoconstraints={}
var wgs84dest = new proj4.Proj('EPSG:4326'); 
var curQueryResultTTL=""
var curposmarker=null;
$( function() {
        epsg=""
        for(val in epsgdefs){
            if(val=="EPSG:4326"){
                epsg+="<option value=\""+val+"\" selected=\"selected\">"+val+"</option>"
            }else{
                epsg+="<option value=\""+val+"\">"+val+"</option>"
            }
        }
        $("#epsgqueryexport").html(epsg);
        $("#epsgqueryimport").html(epsg);
	  document.getElementById('file-input')
	  .addEventListener('change', readRDFFile, false);
	  rdfstore.create(function(err, store) {
		if(currdfstore==null){
				currdfstore=store;			
		}
		suppOnt=""
		for(key in supportingOntologies){
                        suppOnt+="<option value=\""+supportingOntologies[key]+"\">"+key+"</option>"
		}
		$('#supportingOntologySel').html(suppOnt)
	  mymap.on('click', function(e) {
	  if(curposmarker!=null){
			mymap.removeLayer(curposmarker);
	  }
	$('#coordinate').val("["+e.latlng.lat + ", " + e.latlng.lng+"]");
	 bboxpoint=turf.point(JSON.parse("["+e.latlng.lat + ", " + e.latlng.lng+"]"));
	curposmarker= new L.marker(e.latlng).addTo(mymap);
});

});

});

function getAllClasses(){
	currdfstore.execute(prefixList+" SELECT DISTINCT ?cls ?clsLabel  WHERE {?ind rdf:type ?cls . ?ind ?rel ?geo. ?geo geo:asWKT ?wkt  . ?cls rdf:type owl:Class . OPTIONAL{?cls rdfs:label ?clsLabel. }} ORDER BY ?cls", function(success,results){ 
        //console.log(success,results)
		result="";
				for(res in results){
					if(!results[res]["cls"]["value"].startsWith("_")){
					prefix=results[res]["cls"]["value"].substring(0,results[res]["cls"]["value"].lastIndexOf('#')+1);
					addpref=""
					if(prefix in prefixMap){
						addpref=prefixMap[prefix]+":"
					}
						result+="<option value=\""+results[res]["cls"]["value"]+"\">"+((results[res]["clsLabel"]!=null && results[res]["clsLabel"]["value"]!=null)?
						addpref+results[res]["clsLabel"]["value"]:addpref+results[res]["cls"]["value"].substring(results[res]["cls"]["value"].lastIndexOf('#')+1))+"</option>"
					}
				}
		$('#classeslist').html(result);
		$('#classeslist2').html("<option value=\"?\">?</option>"+result);
		$('#classeslist3').html(result);
		$('#classeslist4').html(result);
	});
}

function exportAsTTL(){
	currdfstore.execute(prefixList+" SELECT DISTINCT ?sub ?pred ?obj  WHERE { ?sub ?pred ?obj . }  ORDER BY ?sub ", function(success,results){ 
        //console.log(success,results)
		result="";
		tosave=""
            for(res in results){
					//console.log(results[res]["obj"])
					if(results[res]["sub"]["value"]!=undefined && results[res]["pred"]["value"]!=undefined && results[res]["obj"]["value"]!=undefined){
					tosave+="<"+results[res]["sub"]["value"]+"> <"+results[res]["pred"]["value"]+"> ";
					if(!results[res]["obj"]["value"].includes("http") || results[res]["pred"]["value"].includes("asGML")){
						tosave+="\""+results[res]["obj"]["value"].replace(new RegExp("\"", 'g'),"\\\"")+"\"^^<"+(results[res]["obj"]["type"]!=undefined?results[res]["obj"]["type"]:"http://www.w3.org/2001/XMLSchema#string")+"> . \n";
					}else{
						tosave+="<"+results[res]["obj"]["value"]+"> . \n";
					}
					}
					
				}
                switch($('#dbexportformat').val()){
					case "ttl":
                                        saveTextAsFile(tosave,"ttl");
                                        break;
					case "gml": exportQueryResult(tosave,"gml"); break;
					case "kml": exportQueryResult(tosave,"kml");break;
					case "geojson": exportQueryResult(tosave,"geojson");break;
					case "geojsonld": exportQueryResult(tosave,"geojsonld");break;
					case "jsonld": exportQueryResult(tosave,"jsonld");break;
				}
				
	});
}

function saveTextAsFile(tosave,fileext)
{
    var textFileAsBlob = new Blob([tosave], {type:'text/plain'});
    var fileNameToSaveAs = "res."+fileext;

    var downloadLink = document.createElement("a");
    downloadLink.download = fileNameToSaveAs;
    downloadLink.innerHTML = "Download File";
    if (window.URL != null)
    {
        // Chrome allows the link to be clicked
        // without actually adding it to the DOM.
        downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
    }
    else
    {
        // Firefox requires the link to be added to the DOM
        // before it can be clicked.
        downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
        downloadLink.onclick = destroyClickedElement;
        downloadLink.style.display = "none";
        document.body.appendChild(downloadLink);
    }

    downloadLink.click();
}


function importGeoJSON(geojson,crs,switchlatlong){
	result=ttlprefixList
	result+="geo:Feature rdf:type owl:Class . \n geo:hasGeometry rdf:type owl:ObjectProperty . \n geo:asWKT rdf:type owl:DatatypeProperty . \n geo:asGeoJSON rdf:type owl:DatatypeProperty . \n geo:asGML rdf:type owl:DatatypeProperty . \n geo:asKML rdf:type owl:DatatypeProperty . \n"
	//console.log(geojson)
	data=JSON.parse(geojson)
	namespace="http://semgis.de/geodata#"
	var wkt = new Wkt.Wkt();
	for(feat in data["features"]){
		indid="<http://semgis.de/geodata#"
		if("id" in data["features"][feat]){
			indid+=data["features"][feat]["id"]
			result+=indid+"> rdf:type geo:Feature . \n"
		}else{
			uuid=generateUUID()
			indid+=uuid
			result+=indid+"> rdf:type geo:Feature . \n"
		}
		//console.log("Ind Result: "+result)
		geometry=data["features"][feat]["geometry"]
		coordsconverted=getCoordArrayFromGML(JSON.stringify(geometry["coordinates"]),epsgdefs[$('#epsgqueryimport option:selected').val()],true,true,true)
		wktString=coordarraytoWKT(coordsconverted,geometry["type"])
		//console.log(geometry)
		wkt=wkt.read(wktString);
		result+=indid+"> geo:hasGeometry "+indid+"_geom> . \n "+indid+"_geom> rdf:type geo:"+geometry["type"]+" . \n geo:"+geometry["type"]+" rdf:type owl:Class . \n "
		+indid+"_geom> geo:asWKT \""+wktString+"\"^^geo:wktLiteral . \n "+indid+"_geom> geo:asGeoJSON \""+JSON.stringify(wkt.toJson()).replace(new RegExp("\"", 'g'),"\\\"")+"\"^^geo:geoJSONLiteral . \n "
		+indid+"_geom> geo:asGML \""+geoJSONGeometryToGML(coordsconverted,geometry["type"]).replace(new RegExp("\"", 'g'),"\\\"")+"\"^^geo:gmlLiteral . \n "
		+indid+"_geom> geo:asKML \""+geoJSONGeometryToKML(coordsconverted,geometry["type"]).replace(new RegExp("\"", 'g'),"\\\"")+"\"^^geo:kmlLiteral . \n "
		
		properties=data["features"][feat]["properties"]
		for(prop in properties){
			result+="<"+namespace+prop+"> rdf:type owl:DatatypeProperty . \n "+indid+"> <"+namespace+prop+"> "+getLiteral(properties[prop])+" . \n"
		}
	}
	lastimportAsTTL=result;
	//console.log(result)
	return result
}

function coordarraytoWKT(coordarray,type){
	wktString=""
	if(type=="LinearRing" || type=="Polygon"){
		wktString+="POLYGON((";
	}else if(type=="Envelope"){
		wktString+="ENVELOPE(";
	}else if(type=="LineString"){
		wktString+="LINESTRING(";
	}else if(type=="Point"){
		wktString+="POINT(";
	}
		i=0;
		while(i<coordarray.length){
			wktString+=coordarray[i]+" "+coordarray[i+1]+", "
			i+=2;
		}
		wktString=wktString.substring(0,wktString.length-2)
	if(type=="LinearRing" || type=="Polygon" ){
		wktString+="))";
	}else{
		wktString+=")";
	}
	//console.log("WKT Result: "+wktString)
	return wktString;
}

function geoJSONGeometryToGML(coordarray,type){
	result="<gml:"+type+"><gml:posList>"
	i=0;
	if(coordarray.length==1){
		while(i<coordarray[0].length){
			result+=coordarray[0][i]+" "+coordarray[0][i+1]+" "
			i+=2;
		}
	}else{
		while(i<coordarray.length){
			result+=coordarray[i]+" "+coordarray[i+1]+" "
			i+=2;
		}
	}
	result=result.substring(0,result.length-2)
	result+="</gml:posList></gml:"+geometry["type"]+">"
	return result;
}

function geoJSONGeometryToKML(coordarray,type){
	result="<kml:"+type+"><kml:coordinates>"
	i=0;
	if(coordarray.length==1){
		while(i<coordarray[0].length){
			result+=coordarray[0][i]+","+coordarray[0][i+1]+" "
			i+=2;
		}
	}else{
		while(i<coordarray.length){
			result+=coordarray[i]+","+coordarray[i+1]+" "
			i+=2;
		}
	}
	result=result.substring(0,result.length-2)
	result+="</kml:coordinates></kml:"+geometry["type"]+">"
	return result;
}

function getLiteral(value){
	if (value!=null && (value=="true" || value=="false")){
		return "\""+value+"\"^^<http://www.w3.org/2001/XMLSchema#boolean>"
	}
	if (value!=null && !isNaN(value) && value.toString().trim().indexOf('.') != -1){
		return "\""+value+"\"^^<http://www.w3.org/2001/XMLSchema#double>"
	}
	if(value!=null && !isNaN(value.toString().trim())){
		return "\""+value+"\"^^<http://www.w3.org/2001/XMLSchema#integer>"
	}
	return "\""+value+"\"^^<http://www.w3.org/2001/XMLSchema#string>"
}


function walkDOM(main) {
    var arr = [];
	var result=ttlprefixList
	depth=0
	parentNodeName=""
	
	strconvertmode=false;
    var loop = function(main,depth,parentNodeName,parentIndName,parentRelationName,strconvertmode,toadd) {
        do {
			//console.log(main.nodeName+" - "+depth)
            arr.push(main);
			end=false;
			if(depth==1 && main.attributes!=null){
				i=0;
				while(i<main.attributes.length){
					if(main.attributes[i].nodeName.includes("xmlns")){
						result+=" @prefix "+main.attributes[i].nodeName.substring(main.attributes[i].nodeName.indexOf(":")+1)+": <"+(main.attributes[i].nodeValue.endsWith("#")?main.attributes[i].nodeValue:main.attributes[i].nodeValue+"#")+"> . \n "
					}
					i++;
				}
			}
			if(depth==3 && !main.nodeName.includes("gml:")){
				try{
				
				if(main.getAttribute("gml:id")==null){
								uuid=generateUUID()
								result+="<"+main.namespaceURI+"#"+main.localName+"> rdf:type owl:Class . \n <"+main.namespaceURI+"#"+uuid+"> rdf:type <"+main.namespaceURI+"#"+main.localName+"> .  \n"
								parentNodeName=main.namespaceURI+"#"+uuid
				}else{
								result+="<"+main.namespaceURI+"#"+main.localName+"> rdf:type owl:Class . \n  <"+main.namespaceURI+"#"+main.getAttribute("gml:id")+"> rdf:type <"+main.namespaceURI+"#"+main.localName+"> . \n"
								parentNodeName=main.namespaceURI+"#"+main.getAttribute("gml:id")
				}
				}catch(err){}
			}
			if(depth>3 && parentNodeName!=""){				
				if(main.nodeName.startsWith("gml:") && !main.nodeName.includes("boundedBy")){
					toadd=""
					relName=""
						if(parentRelationName!="" && parentIndName!=""){
							relName=parentIndName
							result+="<"+parentNodeName.replace(new RegExp(" ", 'g'),"_")+"> "+(parentRelationName.includes(":")?parentRelationName.replace(new RegExp(" ", 'g'),"_"):"<"+parentRelationName.replace(new RegExp(" ", 'g'),"_")+">")+" <"+parentIndName.replace(new RegExp(" ", 'g'),"_")+"> . "
							result+=" <http://www.opengis.net/ont/geosparql#asGML> rdf:type owl:DatatypeProperty . \n  "
						}else{
							relName=parentNodeName
							result+=" <http://www.opengis.net/ont/geosparql#asGML> rdf:type owl:DatatypeProperty . \n  "
						}	
					if(main.firstChild!=null && main.firstChild.nextSibling!=null){						
						xmlString = (new XMLSerializer()).serializeToString(main);					
						//console.log("XMLString: "+xmlString)
						coordsconverted=getCoordArrayFromGML(xmlString,epsgdefs[$('#epsgqueryimport option:selected').val()],true,false,true)
						result+="<"+relName+"> <http://www.opengis.net/ont/geosparql#asGML> \""+convertGMLToOtherCRS(xmlString.replace(new RegExp("\"", 'g'),"\\\"").replace(new RegExp("\n", 'g'),""),coordsconverted)+"\"^^<http://www.opengis.net/ont/geosparql#gmlLiteral> . \n "
						//console.log(coordsconverted)
						wkt=gmlStringToWKT(xmlString,coordsconverted)
						//console.log("WKT: "+wkt)
						result+=" <http://www.opengis.net/ont/geosparql#asWKT> rdf:type owl:DatatypeProperty . \n <"+relName+"> <http://www.opengis.net/ont/geosparql#asWKT> \""+wkt+"\"^^<http://www.opengis.net/ont/geosparql#wktLiteral> . \n "
						geojson=gmlStringToGeoJSON(xmlString,coordsconverted)
						result+=" <http://www.opengis.net/ont/geosparql#asGeoJSON> rdf:type owl:DatatypeProperty . \n <"+relName+"> <http://www.opengis.net/ont/geosparql#asGeoJSON> \""+geojson.replace(new RegExp("\"", 'g'),"\\\"")+"\"^^<http://www.opengis.net/ont/geosparql#geojsonLiteral> . \n "
                        kml=gmlStringToKML(xmlString,coordsconverted)
						result+=" <http://www.opengis.net/ont/geosparql#asKML> rdf:type owl:DatatypeProperty . \n <"+relName+"> <http://www.opengis.net/ont/geosparql#asKML> \""+kml.replace(new RegExp("\"", 'g'),"\\\"")+"\"^^<http://www.opengis.net/ont/geosparql#kmlLiteral> . \n "
					}
					end=true;
				}else if(main.childNodes.length>1 && main.nodeName!="#text"){// && main.firstChild.nodeName!="#text")
					uuid=generateUUID()
					//console.log(main)
					//console.log("OBJECTPROPERTY: "+main.nodeName)
					
					result+=(main.nodeName.includes(":")?main.nodeName:"<"+main.namespaceURI+"#"+main.nodeName+">")+" rdf:type owl:ObjectProperty . <"+main.namespaceURI+"#"+uuid+"> rdf:type "+(main.firstChild.nextSibling.nodeName.includes(":")?main.firstChild.nextSibling.nodeName:"<"+main.firstChild.nextSibling.nodeName+">")+" .  \n"
					result+=" "+(main.firstChild.nextSibling.nodeName.includes(":")?main.firstChild.nextSibling.nodeName:"<"+main.firstChild.nextSibling.nodeName+">")+" rdf:type owl:Class . \n "
					parentIndName=main.namespaceURI+"#"+uuid
					parentRelationName=main.nodeName
					//parentNodeName=main.getAttribute("gml:id")
				}else if(main.childNodes.length==1 && main.firstChild.nodeName=="#text"){
					result+="<"+main.namespaceURI+"#"+main.localName+"> rdf:type owl:DatatypeProperty . \n <"+parentNodeName.replace(new RegExp(" ", 'g'),"_")+"> <"+main.namespaceURI+"#"+main.localName+"> "+getLiteral(main.firstChild.nodeValue)+" . \n"
					end=true;
				}
			}
            if(!end && main.hasChildNodes())
                loop(main.firstChild,depth+1,parentNodeName,parentIndName,parentRelationName,strconvertmode,toadd);
			
        }
        while (main = main.nextSibling);
    }
    loop(main,depth,parentNodeName,"","",strconvertmode,"");
	//console.log(result)
	lastimportAsTTL=result;
    return result;
}

function convertGMLToOtherCRS(gmlString,coordarray){
	if(gmlString.includes("posList") || gmlString.includes("pos")){
		firststep=gmlString.indexOf("<gml:posList")+13;
		return gmlString.substring(0,gmlString.indexOf(">",firststep)+1)+coordarray.toString().replace(new RegExp(",",'g')," ")+gmlString.substring(gmlString.indexOf("</gml:posList>"))
	}
	if(gmlString.includes("lowerCorner")){
		lowerCorner=gmlString.substring(gmlString.indexOf("<gml:lowerCorner>")+17,gmlString.indexOf("</gml:lowerCorner>")).trim();
		upperCorner=gmlString.substring(gmlString.indexOf("<gml:upperCorner>")+17,gmlString.indexOf("</gml:upperCorner>")).trim();
		lowersplit=lowerCorner.split(" ")
		uppersplit=upperCorner.split(" ")
		return gmlString.substring(0,gmlString.indexOf("<gml:lowerCorner>")+17)+lowersplit[0]+" "+uppersplit[0]+gmlString.substring(gmlString.indexOf("</gml:lowerCorner>"),gmlString.indexOf("<gml:upperCorner>")+17)+lowersplit[1]+" "+uppersplit[1]+gmlString.substring(gmlString.indexOf("</gml:upperCorner>"))
		//return lowersplit[0]+","+uppersplit[0]+","+lowersplit[1]+","+uppersplit[1]
	}
	return null;
}

function walkDOMKML(main) {
    var arr = [];
	var result=ttlprefixList
	depth=0
	parentNodeName=""
	classopen=-1;
    var loop = function(main,depth,parentNodeName, folderopen,folderopenURI, classopen,styleopen) {
        do {
			console.log(main+" - "+depth)
            arr.push(main);
			end=false;
			//console.log(depth+" - "+classopen)
			if(classopen<depth && classopen!=-1){
				if(main.hasChildNodes()==1){
					if(main.localName.includes("name")){
						result+="<"+parentNodeName+"> rdfs:label "+getLiteral(main.firstChild.nodeValue.replace(new RegExp("\"", 'g')))+" . \n"
					}else if(main.localName.includes("description")){
						result+="<"+parentNodeName+"> rdfs:comment "+getLiteral(main.firstChild.nodeValue.replace(new RegExp("\"", 'g')))+" . \n"
					}else if(main.localName.includes("styleUrl")){
						result+="<"+parentNodeName+"> <"+main.namespaceURI+"#"+main.localName+"> <"+main.namespaceURI+main.firstChild.nodeValue+"> . \n"
					}else{
						result+="<"+main.namespaceURI+"#"+main.localName+"> rdf:type owl:DatatypeProperty . <"+parentNodeName+"> <"+main.namespaceURI+"#"+main.localName+"> "+getLiteral(main.firstChild.nodeValue.replace(new RegExp("\"", 'g')))+" . \n"
					}
					end=true;
				}
			}else if(folderopen!=-1){
				if(main.hasChildNodes()==1){
					if(main.localName=="name"){
						result+="<"+folderopenURI+"> rdfs:label "+getLiteral(main.firstChild.nodeValue.replace(new RegExp("\"", 'g')))+" . \n"
					}else if(main.localName=="description"){
						result+="<"+folderopenURI+"> rdfs:comment "+getLiteral(main.firstChild.nodeValue.replace(new RegExp("\"", 'g')))+" . \n"
					}else if(main.firstChild!=null && main.firstChild.nodeValue!=null)
						result+="<"+main.namespaceURI+"#"+main.localName+"> rdf:type owl:DatatypeProperty . <"+folderopenURI+"> <"+main.namespaceURI+"#"+main.localName+"> "+getLiteral(main.firstChild.nodeValue.replace(new RegExp("\"", 'g')))+" . \n"
				}
			}
				if(main.nodeName=="Style"){
					uuid=generateUUID()
					result+="<"+main.namespaceURI+"#"+main.localName+"> rdf:type owl:Class . <"+main.namespaceURI+"#"+uuid+"> rdf:type <"+main.namespaceURI+"#"+main.localName+"> .  <"+main.namespaceURI+"#"+uuid+"> rdfs:label \""+main.getAttribute("id")+"\" .  \n"
					styleopen=depth;
				}else if(main.nodeName=="Folder"){
					uuid=generateUUID()
					result+="<"+main.namespaceURI+"#"+main.localName+"> rdf:type owl:Class . <"+main.namespaceURI+"#"+uuid+"> rdf:type <"+main.namespaceURI+"#"+main.localName+"> .  \n"
					folderopen=depth;
					folderopenURI=main.namespaceURI+"#"+uuid
				}else if(main.nodeName=="Placemark"){
					uuid=generateUUID()
					result+="<"+main.namespaceURI+"#"+main.localName+"> rdf:type owl:Class . <"+main.namespaceURI+"#"+uuid+"> rdf:type <"+main.namespaceURI+"#"+main.localName+"> .  \n"
					if(folderopen!=-1){
						result+="<http://www.opengis.net/kml/2.2#hasPlacemark> rdf:type owl:ObjectProperty . <"+folderopenURI+"> <http://www.opengis.net/kml/2.2#hasPlacemark> <"+main.namespaceURI+"#"+uuid+"> .  \n"
					}
					classopen=depth;
					parentNodeName=main.namespaceURI+"#"+uuid
					console.log("New Class Open: "+classopen)
				}	
			if(!end && main.hasChildNodes())
                loop(main.firstChild,depth+1,parentNodeName,folderopen,folderopenURI,classopen,styleopen);			
        }
        while (main = main.nextSibling);
    }
    loop(main,-1,"",-1,"",-1,-1);
	//console.log(result)
	lastimportAsTTL=result;
    return arr;
}


function generateUUID() {
    var d = new Date().getTime();
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d/16);
        return (c=='x' ? r : (r&0x3|0x8)).toString(16);
    });
    return uuid;
};

function getAllProperties(){
	currdfstore.execute(prefixList+" SELECT DISTINCT ?prop ?proplabel  WHERE { {?cls rdf:type owl:Class . ?ind rdf:type ?cls . ?ind ?prop ?clsLabel. OPTIONAL{?prop rdfs:label ?proplabel .} } }  ORDER BY ?prop ", function(success,results){ 
        //console.log(success,results)
		result="";
				for(res in results){
					prefix=results[res]["prop"]["value"].substring(0,results[res]["prop"]["value"].lastIndexOf('#')+1);
					addpref=""
					if(prefix in prefixMap){
						addpref=prefixMap[prefix]+":"
					}
					result+="<option value=\""+results[res]["prop"]["value"]+"\">"+((results[res]["proplabel"]!=null && results[res]["proplabel"]["value"]!=null)?
						addpref+results[res]["proplabel"]["value"]:addpref+results[res]["prop"]["value"].substring(results[res]["prop"]["value"].lastIndexOf('#')+1))+"</option>"
				}
		$('#attributelist').html(result);
	});
}

function loadSupportingOntology(){
                $('#loadSupp').disabled=true;
		rdfstore.create(function(err, store) {
		if(currdfstore==null){
				currdfstore=store;			
		}
			console.log("SupportingOntology: "+$('#queryimportformat').val()+" - "+supportingOntologies[$('#queryimportformat').val()])
			ress=""
			$.ajax({url: $('#supportingOntologySel option:selected').val(),async: true, success: function(result){
				console.log(result)
				ress=result;
				currdfstore.load('text/turtle', ress, function(s,d){
                                    $('#loadSupp').disabled=false;
				});
			}});
		});
}

function readRDFFile(e){
	console.log(e)
	var file = e.target.files[0];
	console.log(file)
	if (!file) {
	    return;
	}

	var reader = new FileReader();
	
	reader.onload = function(e) {
	    var contents = e.target.result;
		//console.log(contents)
		rdfstore.create(function(err, store) {
		if(currdfstore==null){
				currdfstore=store;			
		}
		switch($('#queryimportformat').val()){
					case "aaa": contents=walkDOM(new DOMParser().parseFromString(contents, "text/xml")); break;
					case "geojson": contents=importGeoJSON(contents);break;
					case "gml": contents=walkDOM(new DOMParser().parseFromString(contents, "text/xml")); break;
					case "inspire": contents=walkDOM(new DOMParser().parseFromString(contents, "text/xml")); break;
					case "kml": contents=walkDOMKML(new DOMParser().parseFromString(contents, "text/xml")); break;
					case "ttl":  break;
					case "xplanung": contents=walkDOM(new DOMParser().parseFromString(contents, "text/xml")); break;	
		}
		currdfstore.load('text/turtle', contents, function(s,d){
				//console.log(s,d);
				markercollection=[]
				firstpoint=false;
				uiQuery(true)
				});
		});
	};	
	text=reader.readAsText(file);    
}

function uiQuery(start){
        curQueryResultTTL=""
	if(start){
		getAllClasses();  
		getAllProperties(); 
	}
	firstpoint=false;
	if(bboxpoint!=null)
		bboxbuffer=turf.buffer(bboxpoint, $('#buffersize').val(), {units: "meters"})
	//console.log(bboxbuffer)
	clearMap();
	classesToQuery=$('#classeslist').val();
	//console.log(classesToQuery);
	if(!start){
	if(classesToQuery.length==0){
		alert("No classes to query!")
		return
	}
	queryString=prefixList+" SELECT DISTINCT ?person ?rel ?pointstyle ?linestyle ?polygonstyle ?img ?linestringImageStyle ?linestringImage ?val ?valLabel ?wkt ?gml ?kml ?geojson WHERE { "
	for(cls in classesToQuery){
		console.log(cls)
		if($('#whichactive').is(':checked')){
						queryString+="{?person rdf:type <"+classesToQuery[cls]+"> . ?person ?rel ?val .  OPTIONAL{?val geo:asWKT ?wkt .} OPTIONAL{?val geo:asGML ?gml .} OPTIONAL{?val geo:asKML ?kml .} OPTIONAL{?val geo:asGeoJSON ?geojson .}  OPTIONAL{?val rdfs:label ?valLabel .} OPTIONAL{<"+classesToQuery[cls]+"> semgis:pointStyle ?pointstyle .} OPTIONAL{<"+classesToQuery[cls]+"> semgis:lineStyle ?linestringStyle .} OPTIONAL{<"+classesToQuery[cls]+"> semgis:polygonStyle ?polygonstyle .}   OPTIONAL{<"+classesToQuery[cls]+"> semgis:image ?img .} OPTIONAL{<"+classesToQuery[cls]+"> semgis:linestringImageStyle  ?linestringImageStyle .}  OPTIONAL{<"+classesToQuery[cls]+"> semgis:linestringImage  ?linestringImage .}  "
						if(classesToQuery[cls] in constraints){
							queryString+=constraints[classesToQuery[cls]]
						}
						if("?" in constraints){
							for(cons in constraints["?"]){
								queryString+=constraints["?"][cons]
							}
						}
						queryString+="} UNION"
		}else{
			queryString+="{?person rdf:type <"+classesToQuery[cls]+"> . ?person ?rel ?val . OPTIONAL{?val geo:asWKT ?wkt .} OPTIONAL{?val geo:asGML ?gml .} OPTIONAL{?val geo:asKML ?kml .} OPTIONAL{?val geo:asGeoJSON ?geojson .}   OPTIONAL{?val rdfs:label ?valLabel .} OPTIONAL{<"+classesToQuery[cls]+"> semgis:pointStyle ?pointstyle .} OPTIONAL{<"+classesToQuery[cls]+"> semgis:linestringStyle ?linestyle .} OPTIONAL{<"+classesToQuery[cls]+"> semgis:polygonStyle ?polygonstyle .}  OPTIONAL{<"+classesToQuery[cls]+"> semgis:image ?img .} OPTIONAL{<"+classesToQuery[cls]+"> semgis:linestringImageStyle ?linestringImageStyle.} OPTIONAL{<"+classesToQuery[cls]+"> semgis:linestringImage  ?linestringImage .}  } UNION "
		}
	}
	queryString=queryString.substring(0,queryString.length-6)
	}else{
		queryString=prefixList+" SELECT ?person ?rel ?pointstyle ?polygonstyle ?linestyle ?linestringImage ?linestringImageStyle ?img ?val ?valLabel ?wkt ?gml ?kml ?geojson WHERE { ?percls rdf:type owl:Class .  OPTIONAL{?percls semgis:polygonStyle ?polygonstyle .} OPTIONAL{?percls semgis:linestringStyle ?linestyle .} OPTIONAL{?percls semgis:pointStyle ?pointstyle .} OPTIONAL{?percls semgis:image ?img .} OPTIONAL{?percls semgis:linestringImageStyle ?linestringImageStyle .} OPTIONAL{?percls semgis:linestringImage ?linestringImage .} ?person rdf:type ?percls . ?person ?rel ?val . OPTIONAL{?val geo:asWKT ?wkt .} OPTIONAL{?val geo:asGML ?gml .} OPTIONAL{?val geo:asKML ?kml .} OPTIONAL{?val geo:asGeoJSON ?geojson .}  OPTIONAL {?val rdfs:label ?valLabel . } "
	}
	queryString+="} ORDER BY ?person "
	console.log(queryString)
	currdfstore.execute(queryString, function(success,results){ 
        //console.log(success,results)
		persons={}
		classTopers={}
		for(res in results){
		//console.log(results[res])
			if(!(results[res]["person"]["value"] in persons)){
				persons[results[res]["person"]["value"]]={}
			}
			if(results[res]["rel"]["value"]=="asWKT"){
				//console.log("Rel: "+results[res]["rel"]["value"]+" - "+results[res]["val"]["value"])
			}
			if(!(results[res]["rel"]["value"] in persons[results[res]["person"]["value"]])){
				persons[results[res]["person"]["value"]][results[res]["rel"]["value"]]=[]
			}
			if(results[res]["rel"]["value"].includes("type")){
			//console.log("Rel: "+results[res]["rel"]["value"]+" - "+results[res]["val"]["value"]+" - "+results[res]["person"]["value"])
                            if(!(results[res]["val"]["value"]  in classTopers)){
                                classTopers[results[res]["val"]["value"]]=[]
                            }
                            classTopers[results[res]["val"]["value"]].push(results[res]["person"]["value"])
			}
			//console.log(results[res]["val"]["value"])
			if(results[res]["person"]["value"]!=undefined && results[res]["rel"]["value"]!=undefined && results[res]["val"]["value"]!=undefined){
					curQueryResultTTL+="<"+results[res]["person"]["value"]+"> <"+results[res]["rel"]["value"]+"> ";
					if(!results[res]["val"]["value"].includes("http") || results[res]["rel"]["value"].includes("asGML")){
						curQueryResultTTL+="\""+results[res]["val"]["value"].replace(new RegExp("\"", 'g'),"\\\"")+"\"^^<"+(results[res]["val"]["type"]!=undefined?results[res]["val"]["type"]:"http://www.w3.org/2001/XMLSchema#string")+"> . \n";
					}else{
						curQueryResultTTL+="<"+results[res]["val"]["value"]+"> . \n";
					}
			}
			app={}
			app[results[res]["val"]["value"]]=(results[res]["valLabel"]!=null?results[res]["valLabel"]["value"]:results[res]["val"]["value"])
			//console.log(results[res]["person"]["value"])
			persons[results[res]["person"]["value"]][results[res]["rel"]["value"]].push(app)
			if(results[res]["pointstyle"]!=null){
                            persons[results[res]["person"]["value"]]["pointStyle"]=results[res]["pointstyle"]["value"]
			}
                        if(results[res]["polygonstyle"]!=null){
                            persons[results[res]["person"]["value"]]["polygonStyle"]=results[res]["polygonstyle"]["value"]
			}
			if(results[res]["linestyle"]!=null){
                            persons[results[res]["person"]["value"]]["linestringStyle"]=results[res]["linestyle"]["value"]
			}
			if(results[res]["linestringImageStyle"]!=null){
                            persons[results[res]["person"]["value"]]["linestringImageStyle"]=results[res]["linestringImageStyle"]["value"]
			}
                        if(results[res]["linestringImage"]!=null){
                            persons[results[res]["person"]["value"]]["linestringImage"]=results[res]["linestringImage"]["value"]
			}
			if(results[res]["wkt"]!=null && !results[res]["wkt"]["value"].includes("ENVELOPE")){
                                persons[results[res]["person"]["value"]]["asWKT"]=results[res]["wkt"]["value"]
                                curQueryResultTTL+="<"+results[res]["person"]["value"]+"> geo:asWKT \""+results[res]["wkt"]["value"]+"\"^^geo:wktLiteral \n ";
			}
			if(results[res]["gml"]!=null && !results[res]["gml"]["value"].includes("Envelope")){
                                console.log(results[res]["gml"]["value"])
                                curQueryResultTTL+="<"+results[res]["person"]["value"]+"> geo:asGML \""+results[res]["gml"]["value"]+"\"^^geo:gmlLiteral \n ";
                                persons[results[res]["person"]["value"]]["asGML"]=results[res]["gml"]["value"]
                                console.log("Added to curQueryResultTTL!!!")
                                console.log(curQueryResultTTL)
                                
			}
			if(results[res]["kml"]!=null && !results[res]["kml"]["value"].includes("Envelope")){
                                persons[results[res]["person"]["value"]]["asKML"]=results[res]["kml"]["value"]
                                curQueryResultTTL+="<"+results[res]["person"]["value"]+"> geo:asKML \""+results[res]["kml"]["value"]+"\"^^geo:kmlLiteral \n ";
			}
			if(results[res]["geojson"]!=null && !results[res]["geojson"]["value"].includes("Envelope")){
                                persons[results[res]["person"]["value"]]["asGeoJSON"]=results[res]["geojson"]["value"]
                                curQueryResultTTL+="<"+results[res]["person"]["value"]+"> geo:asGeoJSON \""+results[res]["geojson"]["value"]+"\"^^geo:geoJSONLiteral \n ";
			}
			
			if(results[res]["img"]!=null){
                                persons[results[res]["person"]["value"]]["img"]=results[res]["img"]["value"]
			}
		}
		displayQueryResult(persons,!start,classTopers);

	});
}
	
function displayQueryResult(persons,query,classTopers){
	var wkt = new Wkt.Wkt();
		firstpoint=false;
		for(pers in persons){
			markerIconPath=""
			tooltip="<html><b><a href=\""+pers+"\" target=\"_blank\">"+pers.substring(pers.indexOf("#")+1)+"</a></b><ul>"
			Object.keys(persons[pers]).sort().forEach(function(rel) {
				if(rel!=null && (rel.includes("asWKT") || rel.includes("asGML") || rel.includes("asKML") || rel.includes("asGeoJSON") || rel.includes("pointStyle") || rel.includes("polygonStyle") || rel.includes("linestringStyle") || rel.includes("linestringImage") || rel.includes("linestringImageStyle"))){
					}
					else if(rel.includes("img")){
						markerIconPath=persons[pers][rel]
					}else{
						for(val in persons[pers][rel]){
							tooltip+="<li><a href=\""+rel+"\" target=\"_blank\">"+rel.substring(rel.lastIndexOf("#")+1)+"</a> - "
							for(vall in persons[pers][rel][val]){
								tooltip+="<a href=\""+vall+"\" target=\"_blank\">"+(persons[pers][rel][val][vall].includes("#")?persons[pers][rel][val][vall].substring(persons[pers][rel][val][vall].lastIndexOf('#')+1):persons[pers][rel][val][vall])+"</a>"
							}
							tooltip+="</li>"
						}
					}
				});
				//console.log("Geoconstraints: "+JSON.stringify(geoconstraints))
                        rest=[]
                        if(!jQuery.isEmptyObject(geoconstraints)){
								//console.log("GEOCONSTRAINTS!!!!")
                                for(geocons in geoconstraints){
                                        curcons=geoconstraints[geocons]
                                        constraint=curcons.split(" ")
                                        class1=constraint[0]
                                        class2=constraint[2]
                                        relation=constraint[1]
                                        console.log(relation+" - "+classTopers[class1]+" - "+classTopers[class2])
                                        rest.concat(applyFilter(relation,classTopers[class1],classTopers[class2],persons))
                                }
                                
                        }
			for(rel in persons[pers]){
				//console.log("Geometry render loop "+rel+" - "+persons[pers][rel])
				if(rel!=null && rel.includes("asWKT") && !persons[pers][rel].includes("ENVELOPE")){
				//if(persons[pers]["asWKT"]!=null /*&& persons[pers]["asWKT"] in rest*/){
					try{
						//console.log(persons[pers][rel])
						/*if(Array.isArray(persons[pers][rel])){
							wkt.read(persons[pers][rel][0]);
						}else{
							wkt.read(persons[pers][rel]);
						}*/
						if(Array.isArray(persons[pers][rel])){
							if(isJSON(persons[pers][rel][0])){
								console.log(persons[pers][rel][0][Object.keys(persons[pers][rel][0])[0]])
								wkt.read(persons[pers][rel][0][Object.keys(persons[pers][rel][0])[0]]);
							}else{
								console.log(persons[pers][rel][0])
								wkt.read(persons[pers][rel][0]);
							}							
						}else{
							wkt.read(persons[pers][rel]);
						}

						geom=wkt.toJson();
						handleGeometry(geom["type"],geom["coordinates"],query,markerIconPath,pers)
					}catch(err){console.log(err)}//}
				}
		}
		tooltip+="</ul></html>"
	}
}
	
	
function applyFilter(functiondef,set1,set2,persons){
        var wkt=new Wkt.Wkt()
        resultset=[]
        //turf.bbox(set2.values())
		//console.log("ApplyFilter")
        for(elem in set1){			
                if(!(set1[elem] in resultset)){
					//console.log(persons[set1[elem]])
					//console.log(persons[set1[elem]]["asWKT"])
					wkt.read(persons[set1[elem]]["asWKT"])
					curset1=wkt.toJson()
					//console.log("Curset1: "+JSON.stringify(curset1))
                for(elem2 in set2){
                        if(set2[elem2] in resultset){
                            continue;
                        }
                        wkt.read(persons[set2[elem2]]["asWKT"])
                        curset2=wkt.toJson()
						//console.log("Curset2: "+JSON.stringify(curset2))
                        switch(functiondef){
                            case "booleanContains":
									console.log("Contains? "+turf.booleanDisjoint(curset1,curset2))
                                    if(turf.booleanContains(curset1,curset2)){
                                            resultset.push(curset1)
                                            resultset.push(curset2)
                                    }
                                    break;
                            case "booleanCrosses":
								console.log("Crosses? "+turf.booleanDisjoint(curset1,curset2))
                                if(turf.booleanCrosses(curset1,curset2)){
                                            resultset.push(curset1)
                                            resultset.push(curset2)
                                }
                                break;
                           case "booleanDisjoint":
								console.log("Disjoint? "+turf.booleanDisjoint(curset1,curset2))
                                if(turf.booleanDisjoint(curset1,curset2)){
                                            resultset.push(curset1)
                                            resultset.push(curset2)
                                }
                                break;
                        case "booleanEquals":
								console.log("Equals? "+turf.booleanDisjoint(curset1,curset2))
                                if(turf.booleanEquals(curset1,curset2)){
                                            resultset.push(curset1)
                                            resultset.push(curset2)
                                }
                                break;
                     case "booleanOverlap":
							console.log("Overlap? "+turf.booleanDisjoint(curset1,curset2))	
                                if(turf.booleanOverlap(curset1,curset2)){
                                            resultset.push(curset1)
                                            resultset.push(curset2)
                                }
                                break;
                    case "booleanWithin":
							console.log("Within? "+turf.booleanDisjoint(curset1,curset2))
                                if(turf.booleanWithin(curset1,curset2)){
                                            resultset.push(curset1)
                                            resultset.push(curset2)
                                }
                                break;
                        }
                }
                }
        }
        return resultset;        
}
	
function isJSON (something) {
    if (typeof something != 'string')
        something = JSON.stringify(something);

    try {
        JSON.parse(something);
        return true;
    } catch (e) {
        return false;
    }
}
	
function getIconFromPath(markerIconPath){
        if(markerIconPath.startsWith("<svg")){
                    //alert(markerIconPath)
                    markerIconPath = "data:image/svg+xml;base64," + btoa(markerIconPath);
                    //markerIconPath = 'data:image/svg+xml;,' + markerIconPath.replace('#','%23')//"data:image/svg+xml," + 
                    console.log(markerIconPath)
                    //encodeURIComponent(markerIconPath).replace('#','%23');
                    //markerIconPath = "data:image/svg+xml;base64," + btoa(markerIconPath);
                    //markerIconPath=new DOMParser().parseFromString(markerIconPath, "image/svg+xml")
                    //markerIconPath = "data:image/svg+xml," + encodeURIComponent(markerIconPath);
                    //markerIconPath=markerIconPath.replace(new RegExp("\"",'g'),"'")
                    //("data:image/svg+xml," +
                   // markerIconPath).replace('#','%23');
                //<svg xmlns='http://www.w3.org/2000/svg' width='1000' height='1000'><path d='M2,111 h300 l-242.7,176.3 92.7,-285.3 92.7,285.3 z' fill='#000000'/></svg>"
        }
        console.log(markerIconPath)
        var markerIcon = L.icon({
                iconUrl: markerIconPath,
                iconSize: [38, 95], // size of the icon
        });
        return markerIcon;
}
	
function handleGeometry(type,coordinates,query,markerIconPath,pers){
	console.log("Handle Geometry "+type+" "+JSON.stringify(coordinates)+" "+query+" "+firstpoint+" - "+persons[pers]["linestringImageStyle"]+" - "+persons[pers]["linestringImage"] )
	try{
	if(type.toLowerCase()=="point" && coordinates!=null && coordinates[0]!=null){
				if(!query || $('#coordinate').val()=="" || !$('#whereactive').is(':checked')  || (!turf.booleanDisjoint(turf.envelope(turf.point(coordinates)),bboxbuffer))){
				console.log("MAKE POINT MARKER!")
					curQueryResultTTL+="<"+pers+"> <http://www.opengis.net/ont/geosparql#asWKT> \""+coordinates+"\" . \n ";
					/*if(results[res]["person"]["value"]!=undefined && results[res]["rel"]["value"]!=undefined && results[res]["val"]["value"]!=undefined){
						curQueryResultTTL+="<"+results[res]["person"]["value"]+"> <"+results[res]["rel"]["value"]+"> ";
						if(!results[res]["val"]["value"].includes("http") || results[res]["rel"]["value"].includes("asGML")){
							curQueryResultTTL+="\""+results[res]["val"]["value"].replace(new RegExp("\"", 'g'),"\\\"")+"\"^^<"+(results[res]["val"]["type"]!=undefined?results[res]["val"]["type"]:"http://www.w3.org/2001/XMLSchema#string")+"> . \n";
						}else{
							curQueryResultTTL+="<"+results[res]["val"]["value"]+"> . \n";
						}
					}*/
					//console.log("before first point")
					if(!firstpoint && coordinates!=null && coordinates[0]!=null){
						//console.log("Firstcoords")					
						if(Array.isArray(coordinates[0])){
							firstcoords=coordinates[0]
							if(Array.isArray(coordinates[0][0])){
								firstcoords=coordinates[0][0]
								if(Array.isArray(coordinates[0][0][0])){
									firstcoords=coordinates[0][0][0]
								}
							}
						}else{
							firstcoords=coordinates
						}
						mymap.setView(firstcoords, 15);
						firstpoint=true;
					}
						
                        if(markerIconPath!=null && markerIconPath!="" && $('#loadsvg').is(":checked")){
							//console.log("CREATING MARKER AT "+JSON.stringify(coordinates)+" - "+markerIconPath)
                                        markerIcon=getIconFromPath(markerIconPath);
			                var marker = new L.marker(coordinates,{icon:markerIcon}); //opacity may be set to zero
                            marker.bindPopup(tooltip, {maxWidth : 560});
                            marker.addTo(mymap);
                            markercollection.push(marker)
                        } else{
							//console.log("CREATING MARKER AT "+JSON.stringify(coordinates))
                            var marker = new L.marker(coordinates/*,{icon:markerIcon}*/); //opacity may be set to zero
                            marker.bindPopup(tooltip, {maxWidth : 560});
                            marker.addTo(mymap);
                            markercollection.push(marker)
                        }
				}


			}else if(type.toLowerCase()=="linestring" && coordinates!=null && Array.isArray(coordinates)){
			if(!firstpoint && coordinates!=null && coordinates[0]!=null){
				//console.log("Firstcoords")
				if(Array.isArray(coordinates[0])){
					firstcoords=coordinates[0]
					if(Array.isArray(coordinates[0][0])){
						firstcoords=coordinates[0][0]
						if(Array.isArray(coordinates[0][0][0])){
							firstcoords=coordinates[0][0][0]
						}
					}
				}else{
							firstcoords=coordinates
						}
				mymap.setView(firstcoords, 15);
				firstpoint=true;
			}
				if(!query || $('#coordinate').val()=="" || $('#coordinate').val()=="" || !$('#whereactive').is(':checked')  || !turf.booleanDisjoint(turf.envelope(turf.lineString(coordinates)),bboxbuffer)){
				var polyline;
			       if(persons[pers]["linestringStyle"]!=null){
                                        polyline=L.polyline( coordinates,JSON.parse("{"+persons[pers]["linestringStyle"]+"}")).bindPopup(tooltip, {maxWidth : 560}).addTo( mymap);                         
			       }else if(persons[pers]["style"]!=null){
                                    polyline=L.polyline( coordinates,JSON.parse("{"+persons[pers]["style"]+"}")).bindPopup(tooltip, {maxWidth : 560}).addTo( mymap); 
			       }else{
                                polyline=L.polyline( coordinates,{color: 'blue'}).bindPopup(tooltip, {maxWidth : 560}).addTo( mymap); 
			       }
			       if(persons[pers]["linestringImageStyle"]!=null && persons[pers]["linestringImage"]!=null && $('#loadsvg').is(":checked")){
                                    style=JSON.parse(persons[pers]["linestringImageStyle"])
                                    markerIcon=getIconFromPath(persons[pers]["linestringImage"]);
                                    decorators.push(L.polylineDecorator(polyline, {
                                            patterns: [
                                            // defines a pattern of 10px-wide dashes, repeated every 20px on the line
                                                    {offset: style["offset"], repeat: style["repeat"], symbol: L.Symbol.marker({rotate: true, markerOptions: {
                                                                icon: markerIcon
                                                    }})}
                                                ]
                                            }).addTo(mymap));
                                    }
				}

			}else if(coordinates!=null && Array.isArray(coordinates)){//&& personToWKT[pers]["type"]=="Polygon"){
				if(!firstpoint && coordinates!=null && coordinates[0]!=null){
					console.log("Firstcoords")
					if(Array.isArray(coordinates[0])){
						firstcoords=coordinates[0]
						if(Array.isArray(coordinates[0][0])){
							firstcoords=coordinates[0][0]
							if(Array.isArray(coordinates[0][0][0])){
								firstcoords=coordinates[0][0][0]
							}
						}else{
							firstcoords=coordinates
						}
					}
				mymap.setView(firstcoords, 15);
				firstpoint=true;
			}

			if(!query || $('#coordinate').val()=="" || !$('#whereactive').is(':checked') || (!turf.booleanDisjoint(turf.envelope(turf.polygon(coordinates)),bboxbuffer))){
				console.log("CREATING POLYGON AT "+JSON.stringify(coordinates)+" - "+persons[pers]["style"]+" - "+persons[pers]["polygonStyle"])
				 if(persons[pers]["polygonStyle"]!=null){
                                        L.polyline( coordinates,JSON.parse("{"+persons[pers]["polygonStyle"]+"}")).bindPopup(tooltip, {maxWidth : 560}).addTo( mymap);                         
			       }else if(persons[pers]["style"]!=null){
                                poly=L.polygon(coordinates,JSON.parse("{"+persons[pers]["style"]+"}"));
                                poly.bindPopup(tooltip, {maxWidth : 560}).addTo( mymap);
			       }else{
                            poly=L.polygon( coordinates,{color: 'red',});
                                poly.bindPopup(tooltip, {maxWidth : 560}).addTo( mymap);
                           
			       }

			}

			}
			
		}catch(err){
				console.log(err)
			}
}
	
function clearMap() {
    for(i in mymap._layers) {
        if(mymap._layers[i]._path != undefined) {
            try {
                mymap.removeLayer(mymap._layers[i]);
            }
            catch(e) {
                console.log("problem with " + e + mymap._layers[i]);
            }
        }
    }
	for(marker in markercollection){
		mymap.removeLayer(markercollection[marker])
	}
	markercollection=[]
        for(decorator in decorators){
		mymap.removeLayer(decorators[decorator])
	}
	decorators=[]
}

function clearCoords(){
	$('#coordinate').val("")
	mymap.removeLayer(curposmarker);
	curposmarker=null;
}

function addConstraint(firstpart,secondpart,thirdpart){
	if(!$('#'+secondpart).val()=="" && !$('#'+thirdpart).val()==""){
	if($('#'+thirdpart).is("select")){
                geoconstraints[$( "#"+firstpart+" option:selected" ).val()+$( "#"+secondpart+" option:selected" ).val()]=$( "#"+firstpart+" option:selected" ).val()+" "+$( "#"+secondpart+" option:selected" ).val()+" "+$('#'+thirdpart+" option:selected").val()+" ";
		$('#constraints').html($('#constraints').html()+"<li>"+$(  "#"+firstpart+" option:selected" ).text()+" - "+$( "#"+secondpart+" option:selected" ).text()+" - "+$('#'+thirdpart+" option:selected").val()+"</li>")
	}else{
			if($( "#"+firstpart+" option:selected" ).val().includes("?")){
				if(!($( "#"+firstpart+" option:selected" ).val() in constraints)){
					constraints["?"]=[]
				}
				constraints["?"].push(" ?person <"+$( "#"+secondpart+" option:selected" ).val()+"> "+getLiteral($('#'+thirdpart).val())+" . ");

			}else{
				constraints[$( "#"+firstpart+" option:selected" ).val()]=" ?person <"+$( "#"+secondpart+" option:selected" ).val()+"> "+getLiteral($('#'+thirdpart).val())+" . ";
			}
                		$('#constraints').html($('#constraints').html()+"<li>"+$(  "#"+firstpart+" option:selected" ).text()+" - "+$( "#"+secondpart+" option:selected" ).text()+"=\""+$('#'+thirdpart).val()+"\"</li>")
		$('#'+thirdpart).val("")
	}
	}
	if(!$('#classeslist option:selected[value="'+$( "#"+firstpart+"  option:selected" ).val()+'"]')){
		//console.log("SELECTED")
		$('#classeslist option:selected[value="'+$( "#"+firstpart+" option:selected" ).val()+'"]').prop("selected","selected");
	}
	
}

function clearConstraints(){
	$('#constraints').html("");
	contraints=[]
}

function replaceWithNSPrefix(replaceString,namespaces){
        //console.log("ReplaceString: "+replaceString+" - "+JSON.stringify(namespaces))
        prefix=replaceString.substring(0,replaceString.indexOf('#')+1)
        if(prefix in namespaces){
                return namespaces[prefix]+":"+replaceString.substring(replaceString.indexOf('#')+1)
        }
        return replaceString
}

function exportQueryResult(tosave,exportFormat){
        if(exportFormat==undefined){
                exportFormat=$( "#queryexportformat option:selected" ).val();
        }
        if(tosave==undefined){
                tosave=curQueryResultTTL
        }
        console.log(tosave)
	console.log($( "#queryexportformat option:selected" ).val())
	if(exportFormat=="ttl" || $( "#queryexportformat option:selected" ).val()=="ttl"){
		saveTextAsFile(tosave,"ttl")
	}
	if(exportFormat=="gml" || $( "#queryexportformat option:selected" ).val()=="gml"){
        namespaces={}
        namespaces2={}
        gmlstart="<?xml version=\"1.0\"  encoding=\"utf-8\" standalone=\"yes\" ?><gml:FeatureCollection xmlns:gml=\"http://www.opengis.net/gml/3.2\" "
		gml=""
		remembersub1=""
		curgmlid="";
		towrite=[]
		wrotetype=false;
		nscounter=1;
		waitingForGeomTag=""
		waitingForGeomTextContent=""
		splitt=tosave.split("\n")
		for(spl in splitt){
			//console.log(splitt[spl])
			subsplit=splitt[spl].trim().split(" ")

			
			console.log(subsplit)
			//if(remembersub1="" || rememberremembersub1=subsplit[1]){
			try{
						i=0;
                                while(i<subsplit.length){
                                    console.log("Subsplit: "+subsplit[i])
                                    if(subsplit[i].includes("#") && subsplit[i].includes("<http:")  && !subsplit[i].includes("^^") && !(subsplit[i].substring(1,subsplit[i].indexOf('#')+1) in namespaces2)){
                                            namespaces2[subsplit[i].substring(1,subsplit[i].indexOf('#')+1)]="n."+nscounter
                                            namespaces["n."+nscounter]=subsplit[i].substring(1,subsplit[i].indexOf('#')+1)
                                            nscounter++;
                                    }
                                    i++
                                }
			if(splitt[spl].includes("asGML") && !splitt[spl].includes("Envelope")){
                console.log("ASGML: "+splitt[spl])
                if(waitingForGeomTag!=""){
                    gml+="<"+replaceWithNSPrefix(waitingForGeomTag.replace("<","").replace(">",""),namespaces2)+"> \n"
					xmlString=splitt[spl].substring(splitt[spl].indexOf('"')+1,splitt[spl].indexOf("^^")-1)
					coordsconverted=getCoordArrayFromGML(xmlString,epsgdefs[$('#epsgqueryexport option:selected').val()],true,false,false)					
					result=convertGMLToOtherCRS(xmlString,coordsconverted)
					console.log(result)
                    gml+=result+"\n"
                    gml+="</"+replaceWithNSPrefix(waitingForGeomTag.replace("<","").replace(">",""),namespaces2)+">\n"
                    waitingForGeomTag=""
                    waitingForGeomTextContent=""
                }else{
                    gml+=splitt[spl].substring(splitt[spl].indexOf('"')+1,splitt[spl].indexOf("^^")-1)+"\n"
                }
			}else if(splitt[spl].includes("NamedIndividual") || splitt[spl].includes("label") || splitt[spl].includes("http://www.w3.org/2002/07/owl#")  || splitt[spl].includes("comment") || 
			splitt[spl].includes("asWKT") || 
			splitt[spl].includes("asGeoJSON") || 
			splitt[spl].includes("asKML") || splitt[spl].includes("gml:id")){
				continue;
			}
			console.log(splitt[spl])
			gmlid=subsplit[0].substring(subsplit[0].indexOf('#')+1).replace("<","").replace(">","");
			if(curgmlid!=gmlid){
				wrotetype=false;
				curgmlid=gmlid;
			}

			if(curgmlid==gmlid && !wrotetype && !splitt[spl].includes("type")){
				towrite.push(splitt[spl])
			}else if(!splitt[spl].includes("type") && !splitt[spl].includes("asGML")){
                                textContent=(subsplit[2].includes("^^")?subsplit[2].substring(0,subsplit[2].indexOf("^^")-1).replace("<","").replace("\"",""):subsplit[2].replace("<","").replace(">","").replace("\"",""));
                                if((textContent.split("-").length - 1)>=4){
                                        if(waitingForGeomTag!=""){
                                               gml+="<"+replaceWithNSPrefix(waitingForGeomTag.replace("<","").replace(">",""),namespaces2)+">\n"
                                                gml+=waitingForGeomTextContent
                                                gml+="</"+replaceWithNSPrefix(waitingForGeomTag.replace("<","").replace(">",""),namespaces2)+">\n"
                                                waitingForGeomTag=""
                                                waitingForGeomTextContent=""
                                        }
                                        waitingForGeomTag=subsplit[1]
                                        waitingForGeomTextContent=textContent
                                }else{
					gml+="<"+replaceWithNSPrefix(subsplit[1].replace("<","").replace(">",""),namespaces2)+">"+textContent+"</"+replaceWithNSPrefix(subsplit[1].replace("<","").replace(">",""),namespaces2)+">\n"
                                }
			}
			if(splitt[spl].includes("type") && !splitt[spl].includes("asGML")){
					console.log("IN TYPE CLAUSE")
					if(!remembersub1==""){
						gml+="</"+replaceWithNSPrefix(remembersub1.replace("<","").replace(">",""),namespaces2)+">\n"
					}

					gml+="<"+replaceWithNSPrefix(subsplit[2].replace("<","").replace(">",""),namespaces2)+" gml:id=\""+subsplit[0].substring(subsplit[0].indexOf('#')+1).replace("<","").replace(">","")+"\">\n"
					remembersub1=subsplit[2]
					wrotetype=true;
					for(item in towrite){
						subsplit=towrite[item].split(" ")
						gml+="<"+replaceWithNSPrefix(subsplit[1].replace("<","").replace(">",""),namespaces2)+">"+(subsplit[2].includes("^^")?subsplit[2].substring(0,subsplit[2].indexOf("^^")-1).replace("<","").replace("\"",""):subsplit[2].replace("<","").replace(">","").replace("\"",""))+"</"+replaceWithNSPrefix(subsplit[1].replace("<","").replace(">",""),namespaces2)+">\n"
					}
					towrite=[]
			}

			}catch(err){console.log(err)}
		}
		gml+="</"+replaceWithNSPrefix(remembersub1.replace("<","").replace(">",""),namespaces2)+">\n"
		gml+="</gml:FeatureCollection>"
		for(ns in namespaces){
                        gmlstart+=" xmlns:"+ns+"=\""+namespaces[ns]+"\" "
		}
		gmlstart+="> \n"
		gml=gmlstart+gml
		console.log(gml)
		saveTextAsFile(gml,"gml")
	}
	if(exportFormat=="geojson" || $( "#queryexportformat option:selected" ).val()=="geojson"){
		var collection = {
			"type": "FeatureCollection",
			"features": []
		};
        var geojson={"type":"Feature","properties":{}}
		var empty={"type":"Feature","properties":{}}
		first=true;
		if(tosave!=null){
		lastspl1=""
		splitt=tosave.split("\n")
		for(spl in splitt){
			console.log(splitt[spl])
			subsplit=splitt[spl].trim().split(" ")
			//console.log(subsplit)
			//if(remembersub1="" || rememberremembersub1=subsplit[1]){
			
			if(splitt[spl].includes("NamedIndividual") || splitt[spl].includes("label") || splitt[spl].includes("http://www.w3.org/2002/07/owl#")  || splitt[spl].includes("comment") || 
				splitt[spl].includes("asWKT") || 
				splitt[spl].includes("asGML") || 
				splitt[spl].includes("asKML") || splitt[spl].includes("gml:id")){
				continue;
			}
			try{
				if(lastspl1==""){
					lastspl1=subsplit[0].trim()
				}
				else if(lastspl1!=subsplit[0].trim()){
					if(geojson!=empty){
						collection["features"].push(geojson)
						geojson={"type":"Feature","properties":{}}
						lastspl1=subsplit[0].trim()
					}
				}
                if(splitt[spl].includes("asGeoJSON")){				
                    geojson["geometry"]=JSON.parse(splitt[spl].substring(splitt[spl].indexOf('"')+1,splitt[spl].indexOf("^^")-1))["geometry"]
                    geojson["geometry"]["coordinates"]=exportConvert(geojson["geometry"]["coordinates"],epsgdefs[$('#epsgqueryexport option:selected').val()],"geojson",geojson["geometry"]["type"],true)
					console.log("Add converted GeoJSON geometry: "+JSON.stringify(geojson))
                }else if(splitt[spl].includes(":type") || splitt[spl].includes("#type")  ){
					//console.log("IN TYPE CLAUSE")
					//console.log(splitt[spl])
					geojson["properties"]["id"]=subsplit[0].substring(subsplit[0].indexOf('#')+1).replace("<","").replace(">","")
				}else if(splitt[spl].includes("label")){
					continue;
				}else{
					geojson["properties"][subsplit[1].replace("<","").replace(">","")]=(subsplit[2].includes("^^")?
					subsplit[2].substring(0,subsplit[2].indexOf("^^")-1).replace("<","").replace("\"",""):
					subsplit[2].replace("<","").replace(">","").replace("\"",""))
					//gml+="<"+subsplit[1].replace("<","").replace(">","")+">"+(subsplit[2].includes("^^")?subsplit[2].substring(0,subsplit[2].indexOf("^^")-1).replace("<","").replace("\"",""):subsplit[2].replace("<","").replace(">","").replace("\"",""))+"</"+subsplit[1].replace("<","").replace(">","")+">\n"
				}
			}catch(err){console.log(err); continue;}
		}
		}
		
		/*if(geojson!=empty){
			collection.features.push(geojson);
		}*/
        
		console.log(collection)
		saveTextAsFile(JSON.stringify(collection, null, 2),"geojson")
	}
	if(exportFormat=="geojsonld" || $( "#queryexportformat option:selected" ).val()=="geojsonld" || exportFormat=="jsonld" || $( "#queryexportformat option:selected" ).val()=="jsonld"){
		var geojsonLD=true;
		if(exportFormat=="geojsonld"){
			geojsonLD=true;
		}else if(exportFormat=="jsonld"){
			geojsonLD=true;
		}
		var collection = {
			"@context": { "geojson": "https://purl.org/geojson/vocab#", "Feature": "geojson:Feature", "FeatureCollection": "geojson:FeatureCollection","GeometryCollection": "geojson:GeometryCollection",
    "LineString": "geojson:LineString","MultiLineString": "geojson:MultiLineString","MultiPoint": "geojson:MultiPoint","MultiPolygon": "geojson:MultiPolygon","Point": "geojson:Point","Polygon": "geojson:Polygon",
    "bbox": {
      "@container": "@list",
      "@id": "geojson:bbox"
    },
    "coordinates": {
      "@container": "@list",
      "@id": "geojson:coordinates"
    },
    "features": {
      "@container": "@set",
      "@id": "geojson:features"
    },
    "geometry": "geojson:geometry",
    "id": "@id",
    "properties": "geojson:properties",
    "type": "@type",
  },"@graph": []
		};
		var context=collection["@context"]
		var graph=collection["@graph"]
        var geojson={"type":"Feature","properties":{}}
		var empty={"type":"Feature","properties":{}}
		first=true;
		if(tosave!=null){
		lastspl1=""
		splitt=tosave.split("\n")
		for(spl in splitt){
			console.log(splitt[spl])
			subsplit=splitt[spl].trim().split(" ")
			//console.log(subsplit)
			//if(remembersub1="" || rememberremembersub1=subsplit[1]){
			
			if(splitt[spl].includes("NamedIndividual") || splitt[spl].includes("label") || splitt[spl].includes("http://www.w3.org/2002/07/owl#")  || splitt[spl].includes("comment") || 
				splitt[spl].includes("asWKT") || 
				splitt[spl].includes("asGML") || 
				splitt[spl].includes("asKML") || splitt[spl].includes("gml:id")){
				continue;
			}
			try{
				if(lastspl1==""){
					lastspl1=subsplit[0].trim()
				}
				else if(lastspl1!=subsplit[0].trim()){
					if(geojson!=empty){
						graph.push(geojson)
						geojson={"type":"Feature","properties":{}}
						lastspl1=subsplit[0].trim()
					}
				}
                if(splitt[spl].includes("asGeoJSON")){				
                    geojson["geometry"]=JSON.parse(splitt[spl].substring(splitt[spl].indexOf('"')+1,splitt[spl].indexOf("^^")-1))["geometry"]
					if(geojsonLD){
						geojson["geometry"]["coordinates"]=exportConvert(geojson["geometry"]["coordinates"],epsgdefs[$('#epsgqueryexport option:selected').val()],"geojson",geojson["geometry"]["type"],true)
					}else{
						geojson["geometry"]={"@value":JSON.stringify(exportConvert(geojson["geometry"]["coordinates"],epsgdefs[$('#epsgqueryexport option:selected').val()],"geojson",geojson["geometry"]["type"],true)),"@type": "http://www.opengis.net/ont/geosparql#geoJSONLiteral"}
					}
				}else if(splitt[spl].includes(":type") || splitt[spl].includes("#type")  ){
					//console.log("IN TYPE CLAUSE")
					//console.log(splitt[spl])
					geojson["properties"]["id"]=subsplit[0].substring(subsplit[0].indexOf('#')+1).replace("<","").replace(">","")
				}else if(splitt[spl].includes("label")){
					continue;
				}else{
					console.log(subsplit[1])
					subl=subsplit[1].replace("<","").replace(">","")
					context[subl.substring(subl.indexOf('#')+1)]=subl
					console.log(JSON.stringify(context))
					geojson["properties"][subsplit[1].replace("<","").replace(">","")]=(subsplit[2].includes("^^")?
					subsplit[2].substring(0,subsplit[2].indexOf("^^")-1).replace("<","").replace("\"",""):
					subsplit[2].replace("<","").replace(">","").replace("\"",""))
					//gml+="<"+subsplit[1].replace("<","").replace(">","")+">"+(subsplit[2].includes("^^")?subsplit[2].substring(0,subsplit[2].indexOf("^^")-1).replace("<","").replace("\"",""):subsplit[2].replace("<","").replace(">","").replace("\"",""))+"</"+subsplit[1].replace("<","").replace(">","")+">\n"
				}
			}catch(err){console.log(err); continue;}
		}
		}
		
		/*if(geojson!=empty){
			collection.features.push(geojson);
		}*/
        
		console.log(collection)
		saveTextAsFile(JSON.stringify(collection, null, 2),"geojson")
	}
	if(exportFormat=="kml" || $( "#queryexportformat option:selected" ).val()=="kml"){
        var namespaces={}
        var namespaces2={}
		kmlstart="<?xml version=\"1.0\"  encoding=\"utf-8\" standalone=\"yes\" ?><kml xmlns:kml=\"http://www.opengis.net/kml/2.2\" "
		kml=""
		remembersub1=""
		curgmlid="";
		towrite=[]
		wrotetype=false;
		splitt=tosave.split("\n")
		classnames={}
		nscounter=0
		classname=""
		for(spl in splitt){
			console.log(splitt[spl])
			subsplit=splitt[spl].trim().split(" ")
			console.log(subsplit)
			//if(remembersub1="" || rememberremembersub1=subsplit[1]){
			try{
			
			i=0;
            while(i<subsplit.length){
                if(subsplit[i].includes("#") && subsplit[i].includes("<http:")  && !subsplit[i].includes("^^") && !(subsplit[i].substring(1,subsplit[i].indexOf('#')+1) in namespaces2)){				
                    namespaces2[subsplit[i].substring(1,subsplit[i].indexOf('#')+1)]="n."+nscounter
                    namespaces["n."+nscounter]=subsplit[i].substring(1,subsplit[i].indexOf('#')+1)
					nscounter++;
                }
                i++
            }
			gmlid=subsplit[0].substring(subsplit[0].indexOf('#')+1).replace("<","").replace(">","");
			if(splitt[spl].includes("asGML") && !splitt[spl].includes("Envelope")){
				xmlString=splitt[spl].substring(splitt[spl].indexOf('"')+1,splitt[spl].indexOf("^^")-1)
				coordsconverted=getCoordArrayFromGML(xmlString,epsgdefs[$('#epsgqueryexport option:selected').val()],false,false,false)				
				kmlgeo=gmlStringToKML(xmlString,coordsconverted)
				//console.log("KMLSTRING To ADD: "+kmlgeo)
				//coords=exportConvert(coords,epsgdefs[$('#epsgqueryexport option:selected').val()],"coords",towrite.substring(towrite.indexOf(':')+1,towrite.indexOf('>'),true))
                classnames[classname]+=kmlgeo+"\n"
			}
			if(splitt[spl].includes("NamedIndividual") || splitt[spl].includes("label") || splitt[spl].includes("http://www.w3.org/2002/07/owl#")  || splitt[spl].includes("gml:id") || splitt[spl].includes("asGML") ||
                    splitt[spl].includes("asWKT") || 
                    splitt[spl].includes("asGeoJSON") || 
                    splitt[spl].includes("asKML")){
				continue;
			}
			if(curgmlid!=gmlid){
				wrotetype=false;
				curgmlid=gmlid;
			}
			if(curgmlid==gmlid && !wrotetype && !splitt[spl].includes("type")){
				towrite.push(splitt[spl])
			}else if(!splitt[spl].includes("type") && !splitt[spl].includes("asKML")){                                   
					classnames[classname]+="<"+replaceWithNSPrefix(subsplit[1].replace("<","").replace(">",""),namespaces2)+">"+(subsplit[2].includes("^^")?subsplit[2].substring(0,subsplit[2].indexOf("^^")-1).replace("<","").replace("\"",""):subsplit[2].replace("<","").replace(">","").replace("\"",""))+"</"+replaceWithNSPrefix(subsplit[1].replace("<","").replace(">",""),namespaces2)+">\n"
			}
			if(splitt[spl].includes("type")){
					console.log("IN TYPE CLAUSE")
					if(!remembersub1==""){
						classnames[classname]+="</kml:Placemark>\n"
					}
                        classname=subsplit[2].replace("<","").replace(">","")
					if(!(classname in classnames)){
                        classnames[classname]=""
					}
                    classnames[classname]+="<kml:Placemark>\n<kml:name>"+subsplit[0].substring(subsplit[0].indexOf('#')+1).replace("<","").replace(">","")+"</kml:name>\n"
					//classnames[classname]+=
					//kml+="<kml:Folder>\n<kml:name>"+subsplit[2].replace("<","").replace(">","")+"</kml:name>\n<kml:Placemark>\n<kml:name>"+subsplit[0].substring(subsplit[0].indexOf('#')+1).replace("<","").replace(">","")+"</kml:name>\n"
					remembersub1=subsplit[2]
					wrotetype=true;
					for(item in towrite){
						subsplit=towrite[item].split(" ")
						classnames[classname]+="<"+replaceWithNSPrefix(subsplit[1].replace("<","").replace(">",""),namespaces2)+">"+(subsplit[2].includes("^^")?subsplit[2].substring(0,subsplit[2].indexOf("^^")-1).replace("<","").replace("\"",""):subsplit[2].replace("<","").replace(">","").replace("\"",""))+"</"+replaceWithNSPrefix(subsplit[1].replace("<","").replace(">",""),namespaces2)+">\n"
					}
					towrite=[]
			}

			}catch(err){}
		}
		for(cls in classnames){
            kml+="<kml:Folder>\n<kml:name>"+cls+"</kml:name>\n"
            kml+=classnames[cls]
            kml+="</kml:Placemark></kml:Folder> \n"
		}
		//kml+="</kml:Placemark>\n</kml:Folder>\n</kml:Document>"
        for(ns in namespaces){
            kmlstart+=" xmlns:"+ns+"=\""+namespaces[ns]+"\" "
		}
		kmlstart+="><kml:Document> \n"
		kml=kmlstart+kml+"</kml:Document></kml>"
		console.log(kml)
		saveTextAsFile(kml,"kml")
	}
}

function gmlStringToWKT(gmlString,coordarray){
	wktString=""
	if(gmlString.includes("LinearRing") || gmlString.includes("Polygon")){
		wktString+="POLYGON((";
	}else if(gmlString.includes("Envelope")){
		wktString+="ENVELOPE(";
	}else if(gmlString.includes("LineString")){
		wktString+="LINESTRING(";
	}else if(gmlString.includes("Point")){
		wktString+="POINT(";
	}
	if(gmlString.includes("posList") || gmlString.includes("pos")){
		i=0;
		while(i<coordarray.length){
			wktString+=coordarray[i]+" "+coordarray[i+1]+", "
			i+=2;
		}
		wktString=wktString.substring(0,wktString.length-2)
	}
	if(gmlString.includes("lowerCorner")){
		/*lowerCorner=gmlString.substring(gmlString.indexOf("<gml:lowerCorner>")+17,gmlString.indexOf("</gml:lowerCorner>")).trim();
		upperCorner=gmlString.substring(gmlString.indexOf("<gml:upperCorner>")+17,gmlString.indexOf("</gml:upperCorner>")).trim();
		lowersplit=lowerCorner.split(" ")
		uppersplit=upperCorner.split(" ")*/
		wktString+=coordarray[0]+" "+coordarray[1]+","+coordarray[2]+" "+coordarray[3]
	}
	if(gmlString.includes("LinearRing") || gmlString.includes("Polygon") ){
		wktString+="))";
	}else{
		wktString+=")";
	}
	//console.log("WKT Result: "+wktString)
	return wktString;
}

function getCoordArrayFromGML(gmlString,crs,switchlatlong,geojson,importOrExport){
	if(gmlString.includes("posList")){
		firststep=gmlString.indexOf("<gml:posList")+13;
		posliststr=gmlString.substring(gmlString.indexOf(">",firststep)+1,gmlString.indexOf("</gml:posList>")).trim();
		//console.log("Original: "+posliststr)
		splstr=posliststr.split(" ")
		if(importOrExport){
			resultarray=importConvert(splstr,crs,switchlatlong)
		}else{
			resultarray=convertit(splstr,epsgdefs["EPSG:4326"],crs,switchlatlong)
			//resultarray=exportConvert(splstr,crs,switchlatlong)
		}
		
		//console.log("Converted: "+resultarray)
		return resultarray;
	}else if(gmlString.includes("pos")){
		firststep=gmlString.indexOf("<gml:pos")+8;
		posliststr=gmlString.substring(gmlString.indexOf(">",firststep)+1,gmlString.indexOf("</gml:pos>")).trim();
		//console.log("Original: "+posliststr)
		splstr=posliststr.split(" ")
		if(importOrExport){
			resultarray=importConvert(splstr,crs,switchlatlong)
		}else{
			resultarray=convertit(splstr,epsgdefs["EPSG:4326"],crs,switchlatlong)
			//resultarray=exportConvert(splstr,crs,switchlatlong)
		}
		//console.log("Converted: "+resultarray)
		return resultarray;
	}
	if(gmlString.includes("lowerCorner")){
		lowerCorner=gmlString.substring(gmlString.indexOf("<gml:lowerCorner>")+17,gmlString.indexOf("</gml:lowerCorner>")).trim();
		upperCorner=gmlString.substring(gmlString.indexOf("<gml:upperCorner>")+17,gmlString.indexOf("</gml:upperCorner>")).trim();
		lowersplit=lowerCorner.split(" ")
		uppersplit=upperCorner.split(" ")
		return lowersplit[0]+","+uppersplit[0]+","+lowersplit[1]+","+uppersplit[1]
	}
	if(geojson){
		splstr=gmlString.replace(new RegExp("\\[",'g'),"").replace(new RegExp("\\]",'g'),"").trim().replace(new RegExp(" ",'g'),",").split(",");
		if(importOrExport){
			resultarray=importConvert(splstr,crs,switchlatlong)
		}else{
			resultarray=convertit(splstr,epsgdefs["EPSG:4326"],crs,switchlatlong)
			//resultarray=exportConvert(splstr,crs,switchlatlong)
		}
		return resultarray;
	}
	return null;
}

function gmlStringToKML(gmlString,coordarray){
	wktString=""
	if(gmlString.includes("LinearRing")){
		wktString+="<kml:Polygon>";
	}else if(gmlString.includes("Envelope")){
		wktString+="<kml:Envelope>";
	}else if(gmlString.includes("LineString")){
		wktString+="<kml:LineString>";
	}else if(gmlString.includes("Point")){
		wktString+="<kml:Point>";
	}
	if(gmlString.includes("posList") || gmlString.includes("pos")){
		wktString+="<kml:coordinates>"
		i=0;
		while(i<coordarray.length){
			wktString+=coordarray[i]+","+coordarray[i+1]+" "
			i+=2;
		}
		wktString=wktString.substring(0,wktString.length-2)
		wktString+="</kml:coordinates>"
	}
	if(gmlString.includes("lowerCorner")){
		/*lowerCorner=gmlString.substring(gmlString.indexOf("<gml:lowerCorner>")+17,gmlString.indexOf("</gml:lowerCorner>")).trim();
		upperCorner=gmlString.substring(gmlString.indexOf("<gml:upperCorner>")+17,gmlString.indexOf("</gml:upperCorner>")).trim();
		lowersplit=lowerCorner.split(" ")
		uppersplit=upperCorner.split(" ")*/
		wktString+="<kml:coordinates>"
		wktString+=coordarray[0]+","+coordarray[1]+" "+coordarray[2]+","+coordarray[3]
                wktString+="</kml:coordinates>"
	}
	if(gmlString.includes("LinearRing")){
		wktString+="</kml:Polygon>";
	}else if(gmlString.includes("Envelope")){
		wktString+="</kml:Envelope>";
	}else if(gmlString.includes("LineString")){
		wktString+="</kml:LineString>";
	}else if(gmlString.includes("Point")){
		wktString+="</kml:Point>";
	}
	//console.log("WKT Result: "+wktString)
	return wktString;
}

function geometryToGeoJSON(geomtype,coordinates){
    res={}
	res["geometry"]={}
	switch(geomtype){
            case "LinearRing": 
            case "Polygon": 
                res["geometry"]["type"]="Polygon"
		res["geometry"]["coordinates"]="[["
		break;
            case "Envelope":
            res["geometry"]["type"]="Envelope"
		res["geometry"]["coordinates"]="["
		break;
            case "LineString":
                res["geometry"]["type"]="LineString"
		res["geometry"]["coordinates"]="["
		break;
            case "Point":
                res["geometry"]["type"]="Point"
		res["geometry"]["coordinates"]="["
		break;
	}	
	splstr=coordinates.toString().split(",")
	i=0;
		while(i<splstr.length){
			res["geometry"]["coordinates"]+="["+splstr[i]+", "+splstr[i+1]+"], "
			i+=2;
		}
        res["geometry"]["coordinates"]=res["geometry"]["coordinates"].substring(0,res["geometry"]["coordinates"].length-2)
        if(geomtype=="LinearRing" || geomtype=="Polygon"){
		res["geometry"]["coordinates"]+="]]"
	}else{
		res["geometry"]["coordinates"]+="]"
	}
	return JSON.parse(res["geometry"]["coordinates"]);
}

function geometryToKML(geomtype,coordinates){
    res={}
	res["geometry"]={}
	switch(geomtype){
        case "LinearRing": 
        case "Polygon": 
            res["geometry"]["type"]="Polygon"
		res["geometry"]["coordinates"]="[["
		break;
            case "Envelope":
            res["geometry"]["type"]="Envelope"
		res["geometry"]["coordinates"]="["
		break;
            case "LineString":
                res["geometry"]["type"]="LineString"
		res["geometry"]["coordinates"]="["
		break;
            case "Point":
                res["geometry"]["type"]="Point"
		res["geometry"]["coordinates"]="["
		break;
	}	
	splstr=coordinates.toString().split(",")
	i=0;
		while(i<splstr.length){
			res["geometry"]["coordinates"]+="["+splstr[i]+", "+splstr[i+1]+"], "
			i+=2;
		}
        res["geometry"]["coordinates"]=res["geometry"]["coordinates"].substring(0,res["geometry"]["coordinates"].length-2)
        if(geomtype=="LinearRing" || geomtype=="Polygon"){
		res["geometry"]["coordinates"]+="]]"
	}else{
		res["geometry"]["coordinates"]+="]"
	}
	return JSON.parse(res["geometry"]["coordinates"]);
}

function gmlStringToGeoJSON(gmlString,coordarray){
	resu={}
	resu["geometry"]={}
	if(gmlString.includes("LinearRing")){
		resu["geometry"]["type"]="Polygon"
		resu["geometry"]["coordinates"]="[["
	}else if(gmlString.includes("Envelope")){
		resu["geometry"]["type"]="Envelope"
		resu["geometry"]["coordinates"]="["
	}else if(gmlString.includes("LineString")){
		resu["geometry"]["type"]="LineString"
		resu["geometry"]["coordinates"]="["
	}else if(gmlString.includes("Point")){
		resu["geometry"]["type"]="Point"
		resu["geometry"]["coordinates"]="["
	}
	//console.log("RES: "+JSON.stringify(resu))
	if(gmlString.includes("posList")|| gmlString.includes("pos")){
		//console.log("ImportConvert: "+coordarray)
		i=0;
		while(i<coordarray.length){
                       // console.log("["+coordarray[i]+", "+coordarray[i+1]+"]")
                        //console.log(resu)
			resu["geometry"]["coordinates"]+="["+coordarray[i]+", "+coordarray[i+1]+"], "
			i+=2;
		}
		resu["geometry"]["coordinates"]=resu["geometry"]["coordinates"].substring(0,resu["geometry"]["coordinates"].length-2)
	}
	if(gmlString.includes("lowerCorner")){
		/*lowerCorner=gmlString.substring(gmlString.indexOf("<gml:lowerCorner>")+17,gmlString.indexOf("</gml:lowerCorner>")).trim();
		upperCorner=gmlString.substring(gmlString.indexOf("<gml:upperCorner>")+17,gmlString.indexOf("</gml:upperCorner>")).trim();
		lowersplit=lowerCorner.split(" ")
		uppersplit=upperCorner.split(" ")*/
		resu["geometry"]["coordinates"]+="["+coordarray[0]+","+coordarray[1]+"], ["+coordarray[2]+","+coordarray[3]+"]"
	}
	if(gmlString.includes("LinearRing")){
		resu["geometry"]["coordinates"]+="]]"
	}else{
		resu["geometry"]["coordinates"]+="]"
	}
	//console.log("JSON parse: "+
	resu["geometry"]["coordinates"]=JSON.parse(resu["geometry"]["coordinates"])
	//console.log("GeoJSON Result: "+JSON.stringify(resu))
	return JSON.stringify(resu);
}

function importConvert(coordinates,source,switchlatlong){
    return convertit(coordinates,source,epsgdefs["EPSG:4326"],switchlatlong)
}

function exportConvert(coordinates,dest,type,geomtype,switchlatlong){
    console.log("ExportConvert")
    coords=convertit(coordinates,epsgdefs["EPSG:4326"],dest,switchlatlong)
    console.log("Coords: "+coords)
    console.log(type)
    switch(type){
        case "geojson":
           res=geometryToGeoJSON(geomtype,coords)
           console.log("Res: "+res)
           return res; 
		case "coords":
           res=geometryToKML(geomtype,coords)
           console.log("Res: "+res)
           return res;            
    }
    return null;
}

function convertit(coordinates,source,dest,switchlatlong){
	console.log("Coordinates: "+coordinates)
	if(source==dest && !switchlatlong){
            return coordinates;
	}
	resultarray=[]
	console.log(coordinates.length)
	i=0;
	splitted=coordinates.toString().split(",")
	while(i<splitted.length){
		//console.log(splitted[i]+" - "+splitted[i+1]+" - "+parseFloat(splitted[i])+" - "+parseFloat(splitted[i+1]))
		var p=new proj4.Point(splitted[i],splitted[i+1])
		console.log("Point: "+p.x+" - "+p.y)
		//console.log(source)
		//console.log(dest)
		if(source!=dest)
			res=proj4(source, dest, p);
		else{
			res=p;
		}
		console.log("Point: "+res.x+" - "+res.y)
		if(switchlatlong){
			resultarray.push(res.y)
			resultarray.push(res.x)
		}else{
			resultarray.push(res.x)
			resultarray.push(res.y)
		}
		i+=2;
	}
	console.log("Resultarray: "+resultarray)
	return resultarray
}

function clearGraph(){
	currdfstore.clear(function(err){console.log(err)});
	$('#classeslist').html("")
	$('#classeslist2').html("")
	$('#classeslist3').html("")
	$('#classeslist4').html("")
	$('#attributelist').html("")
	clearConstraints();
	clearCoords();
	clearMap();
}

function exportLastImport(){
	exportQueryResult(lastimportAsTTL,$('#lastimportexportformat').val())
	//saveTextAsFile(lastimportAsTTL,"ttl")
}

</script>

</head>
<body>
<h2 align="center">XPlanung Mapview based on LinkedData</h2>
<table height="80%" width="100%" align="top" valign="top"><tr><td width="80%" height="80%" align="top" valign="top" >
<div id="mapid" style="height:90%" width="80%">
<script>

	var mymap = L.map('mapid').setView([51.505, -0.09], 13);

	var layer = L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw', {
		maxZoom: 18,
		attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, ' +
			'<a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
			'Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
		id: 'mapbox.streets'
	}).addTo(mymap);

</script>
</div></td><td align="top" valign="top" width="20%" height="70%" ><h3>Searching in the database</h3><table height="100%"><tr  valign="top" align="top">
<td>WHAT? </td><td><select id="classeslist" multiple  size=15 style="height: 70%;"></select></td></tr>
<tr valign="top" align="top"><td>WHERE? <input type="checkbox" id="whereactive"/></td>
<td>Coordinate: <input id="coordinate" disabled="disabled" size="30"/><button onclick="clearCoords()">Clear</button>
<br/>Boundingboxsize (m):<input type="number" min="1" value="100" id="buffersize"/></td></tr>
<tr valign="top" align="top"><td>Geospatial Constraints?<input type="checkbox" id="geospatialactive"/></td><td><select id="classeslist3"></select>
<select id="geospatiallist">
<option value="booleanContains">contains</option>
<option value="booleanCrosses">crosses</option>
<option value="booleanDisjoint">disjointWith</option>
<option value="booleanEqual">equals</option>
<option value="booleanOverlap">overlaps</option>
<option value="booleanWithin">within</option>
</select><select id="classeslist4"></select><br/><button id="addgeoconstraint"  onClick="addConstraint('classeslist3','geospatiallist','classeslist4')">Add</button>
<button id="clearconstraints" onclick="clearConstraints()">Clear</button></td></tr>
<tr  valign="top" align="top"><td>Which features?<input type="checkbox" id="whichactive"/></td>
<td><select id="classeslist2"></select><select id="attributelist"></select><br/><input type="text" id="constrainttext"/><br/>
<button id="addconstraint" onClick="addConstraint('classeslist2','attributelist','constrainttext')">Add</button>
<button id="clearconstraints" onclick="clearConstraints()">Clear</button></td></tr>
<tr  valign="top" align="top"><td colspan="2"><ul id="constraints"></ul></td></tr>
<tr  valign="top" align="top"><td>Query: </td><td><button id="querybutton" onclick="uiQuery()">Query</button><br/>
<button id="queryasTTL" onclick="exportQueryResult()">Query Result as</button>
<select id="queryexportformat">
<option value="ttl" selected="selected">TTL</option>
<option value="gml">GML</option>
<option value="kml">KML</option>
<option value="geojson">GeoJSON</option>
<option value="geojsonld">GeoJSON-LD</option>
<option value="jsonld">JSON-LD</option>
</select><br/>CRS: <select id="epsgqueryexport"></select></td></tr>
</table>
</td></tr></table><table width="60%"><tr><td colspan="2">
Import From File:<input type="file"  id="file-input" /><br/>Format: <select id="queryimportformat">
<option value="ttl" selected="selected">TTL</option>
<option value="gml">GML</option>
<option value="kml">KML</option>
<option value="geojson">GeoJSON</option>
</select>
CRS: <select id="epsgqueryimport"></select><br/>
Load supporting Ontology:<select id="supportingOntologySel"></select><button id="loadSuppOnt" onclick="loadSupportingOntology()">Load</button><br/>
Load svg images: <input type="checkbox" id="loadsvg"/></td><td align="right">
<button id="exportTTL" onclick="exportAsTTL()">Export Database as</button><select id="dbexportformat">
<option value="ttl" selected="selected">TTL</option>
<option value="gml">GML</option>
<option value="kml">KML</option>
<option value="geojson">GeoJSON</option>
<option value="geojsonld">GeoJSON-LD</option>
<option value="jsonld">JSON-LD</option>
</select><br/>
<button id="exportlastasTTL" onclick="exportLastImport()">Export last imported file as</button><select id="lastimportexportformat">
<option value="ttl" selected="selected">TTL</option>
<option value="gml">GML</option>
<option value="kml">KML</option>
<option value="geojson">GeoJSON</option>
<option value="geojsonld">GeoJSON-LD</option>
<option value="jsonld">JSON-LD</option>
</select><br/><button id="cleargraph" onclick="clearGraph()">Delete Database</button></td></tr></table>
</body>
</html>
